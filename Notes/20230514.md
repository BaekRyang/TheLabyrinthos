# 20230514 Logs
기존 인벤토리는 Dictionary를 이용하여 ID - Amount 방식을 사용하여 인벤토리에서도 해당 ID를 가지고 아이템 리스트에서 해당 ID의 아이템을 ref로 가져와서 업데이트 했었음  
하지만 해당 방식은 같은 ID에 다른 속성의 아이템을 반영하지 못하는 문제가 있음  
따라서 인벤토리를 다음과 같이 수정함

1. 무기 아이템만 변화하는 속성을 지니므로 무기 아이템의 인벤토리를 분리함
```c#
    public Dictionary<int, int> dict_inventory;
    public Dictionary<int, List<Weapon>> dict_weaponInventory;
    //여전히 모든 로직은 ID를 기반으로 사용되므로 ID를 Key로 하되, List를 사용하여 Instance와 Amount를 동시에 저장한다.
```
2. Add, Remove, Has의 로직 변경 - 무기인지 확인하고, 해당 객체를 추가/삭제한다.
``` C#
    public void AddItem(Item item, int amount = 1)
        if (item.IT_type == TypeDefs.ItemType.Weapon)
            {
                if (!dict_weaponInventory.ContainsKey(item.i_id))
                    //해당 무기를 이미 갖고있지 않으면 리스트를 만들어준다.
                    dict_weaponInventory.Add(item.i_id, new List<Weapon>());

                //그 다음 리스트에 아이템을 추가해준다.
                dict_weaponInventory[item.i_id].Add(new Weapon(item as Weapon));
                return;
            }
            ...
            //이외로 Non-Weapon 아이템의 Add작업 실행


    public void RemoveItem(Item item, int amount = 1)
        if (item.IT_type == TypeDefs.ItemType.Weapon)
        {
            //인자로 들어온 해당 아이템을 삭제한다.
            if (dict_weaponInventory[item.i_id].Contains(item as Weapon))
            {
                dict_weaponInventory[item.i_id].Remove(item as Weapon);

                if (dict_weaponInventory[item.i_id].Count == 0)
                    // 해당 무기 아이템 리스트가 비어있으면 딕셔너리에서 제거
                    dict_weaponInventory.Remove(item.i_id); 
            }
            return;
        }
        ...

    public bool HasItem(Item item, int amount = 1)
        if (item.IT_type == TypeDefs.ItemType.Weapon)
        {
            if (dict_weaponInventory.ContainsKey(item.i_id))
                return true;
            else
                return false;
        }
        ...
```
3. 기존의 Item이 아닌 ID가 Parameter로 들어올때의 Overloading 들은 위의 함수를 호출하는 방식으로 수정
4. 인벤토리 UI를 업데이트하는 메서드 수정
```c#
    public void UpdateInventory()
        foreach (var weaponList in InventoryManager.Instance.dict_weaponInventory)
        {
            foreach (var weapon in weaponList.Value)
            {
                GameObject tmpGO;

                tmpGO = Instantiate(copyGO, TF_Weapons);
                tmpGO.GetComponent<ItemObject>().I_item = weapon;
                tmpGO.name = weapon.s_name;
                tmpGO.GetComponent<ItemObject>().UpdateItem();
            }
        }
        ... //이후로 기존 코드실행. 단 아이템이 Weapon인 경우 Break하도록 수정

```
<br>

--- 

<br>

# 조합 시스템 수정
인벤토리가 변경되었으로, 조합 시스템도 수정을 해야함 레시피중 무기가 있다면 다른 처리를 하는 방식으로 수정함
```c#
    public void LoadItemToTable(int destItemID, Dictionary<int,int> recipe) //레시피 클릭하면 위에 올리는 메서드
    {
        //완성품 칸 업데이트
        GO_destItemCell.GetComponent<ItemObject>().I_item = IM_manager.dict_items[destItemID];
        GO_destItemCell.GetComponent<ItemObject>().UpdateItem();

        dict_targetRecipe = recipe; //혹시 다른데서 쓸 지도 모르니깐 저장하고

        int count = 0;
        foreach (var kvp in dict_targetRecipe) //재료 칸에 레시피 따라서 올리고 업데이트
        {
            //셀 켜주고
            GO_resourceCells[count].SetActive(true); 
```
수정된 부분
```c#
            //재료가 만약 무기이면서 소유를 하고있다면 그 중 첫번째를 올린다.
            if (kvp.Key < 100 && IM_manager.HasItem(kvp.Key))
            {
                GO_resourceCells[count].GetComponent<ItemObject>().I_item = IM_manager.GetWeaponInstance(kvp.Key);
                IM_manager.RemoveItem(kvp.Key);
            }
            else
            {
                //무기인데 소유중이 아니거나, 무기가 아닌경우는 원본을 올린다.
                GO_resourceCells[count].GetComponent<ItemObject>().I_item = IM_manager.dict_items[kvp.Key];
                IM_manager.RemoveItem(kvp.Key, kvp.Value);
            }
```

```c#
            GO_resourceCells[count].GetComponent<ItemObject>().UpdateItem(kvp.Value);
            count++;
        }

        InventoryUI.DestroyElements();
        InventoryUI.UpdateInventory();

        for (int i = count; i < 5; i++)
            GO_resourceCells[i].SetActive(false); //안쓰는 칸은 꺼준다.

        CalcCanCraft();
    }
```

해당 방식을 사용하여, 나중에 마우스로 원하는 아이템을 조합창에 Drag&Drop 하는 방식으로 넘어가기 쉽게 변경함  
조합이 가능한지 알아보는 `CalcCanCraft()` 같은 경우도 크게 수정을 해야하나 했었는데, `InventoryManager`의 `HasItem()` 메서드에서 해당 아이템이 무기인지 아닌지 확인하기 때문에 수정할 필요가 없었음

## 조합 시스템 변경사항
기존에는 조합대에 아이템을 올려도 인벤토리에 영향을 주지 않고 조합을 하는 순간에 아이템을 인벤토리에 제거하도록 했었음  
나중에 Drag&Drop 방식에 대비하면서, 무기 아이템을 조합대에 자동으로 올려줄때 순서의 문제를 해결하기 위하여 조합대에 아이템을 올리면 인벤토리에서도 해당 아이템을 제거하도록 수정하였음
```c#
            //재료가 만약 무기이면서 소유를 하고있다면 그 중 첫번째를 올린다.
            if (kvp.Key < 100 && IM_manager.HasItem(kvp.Key))
            {
                GO_resourceCells[count].GetComponent<ItemObject>().I_item = IM_manager.GetWeaponInstance(kvp.Key);
                IM_manager.RemoveItem(kvp.Key);
            }
            else
            {
                //무기인데 소유중이 아니거나, 무기가 아닌경우는 원본을 올린다.
                GO_resourceCells[count].GetComponent<ItemObject>().I_item = IM_manager.dict_items[kvp.Key];
                IM_manager.RemoveItem(kvp.Key, kvp.Value);
            }
```
위의 수정 사항에서 보여준 코드인데, `IM_manager.RemoveItem(kvp.Key);` 와 `IM_manager.RemoveItem(kvp.Key, kvp.Value);` 가 해당 기능을 한다.  
만약 조합을 하지 않고 창을 닫을시에는 해당 아이템을 반환한다.  
```c#
    public void ResetCells() //제작 칸을 전부 비우고 초기화 한다.
    {
        GO_destItemCell.GetComponent<ItemObject>().I_item = null;
        GO_destItemCell.GetComponent<ItemObject>().UpdateItem();
        GO_destItemCell.GetComponent<ItemObject>().b_canClick = false;
```
수정된 부분
```c#
        for (int i = 0; i < 5; i++)
        {
            if (GO_resourceCells[i].activeSelf)
            {
                IM_manager.AddItem(
                    //올라간 아이템을
                    GO_resourceCells[i].GetComponent<ItemObject>().I_item, 

                    //개수만큼 인벤에 다시 넣는다.
                    int.Parse(GO_resourceCells[i].transform.GetChild(1).GetComponent<TMP_Text>().text));
            }
        }
```
```c#
        GO_resourceCells[0].GetComponent<ItemObject>().I_item = null;
        GO_resourceCells[0].GetComponent<ItemObject>().UpdateItem();

        for (int i = 1; i < 5; i++)
            GO_resourceCells[i].SetActive(false);
    }
```
이렇게 변경했으므로, `CraftItem()`에서는 아이템을 따로 조작하지 않고, 제작대를 비워주기만 한다.